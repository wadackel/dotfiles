## 開発ガイド

### Browser Automation

ブラウザを利用する操作には `playwright-cli` スキルを積極的に使用すること。

**Plan mode での実測確認:**
- ブラウザUIやレンダリングに関する技術的問題を Plan mode で調査する際は、理論的推測だけでなく実際に `playwright-cli` で動作確認を行うこと
- 特に DOM 要素のサイズ、CSS 適用状態、レイアウト計算などは、`eval` や `screenshot` で実測値を取得してから計画を立てる
- 例: モバイルビューポートでの表示問題 → `resize` + `screenshot` + `eval` で現象確認 → 原因特定 → 計画作成

**効率的な DOM 値取得:**
- 要素のプロパティ（naturalWidth, offsetWidth, computedStyle 等）を取得する際は、ref 指定の `eval` を使用
- 例: `playwright-cli eval "el => JSON.stringify({w:el.offsetWidth, h:el.offsetHeight})" e42`
- `run-code` よりも簡潔で、エラーハンドリングも不要

### gemini-research スキル使用ガイドライン

以下の状況では、ユーザーが明示的にスキル名を出さなくても、積極的に `gemini-research` スキルを使用すること：

1. **ライブラリ・フレームワーク選定**
   - 「おすすめは？」「どれが良い？」「何を使えば？」のような質問
   - 複数の選択肢を比較する必要がある場合
   - 最新のトレンドや 2026 年の情報が必要な場合
   - 例：「React のテストライブラリでおすすめある？」

2. **エラー調査・トラブルシューティング**
   - ビルドエラー、実行時エラーの解決策を探す場合
   - 「どうやって解決する？」「何が原因？」のような質問
   - エラーメッセージの Web 検索が有効な場合
   - 既知の問題やワークアラウンドを調べる必要がある場合
   - 例：「pnpm install で ERR_PNPM_PEER_DEP_ISSUES が出た。解決方法は？」

3. **ベストプラクティス調査**
   - 「ベストプラクティスは？」「推奨される方法は？」のような質問
   - 最新の設計パターンやアプローチを知る必要がある場合
   - 2026 年の最新トレンドが重要な場合
   - 例：「React Server Components の 2026 年のベストプラクティスを教えて」

4. **API・ライブラリの使い方調査**
   - 初めて使うライブラリや API の実装方法を調べる場合
   - 「使い方は？」「実装例は？」のような質問
   - ドキュメントや実装例が必要な場合
   - 例：「Stripe Checkout を Next.js 15 で使う方法を教えて」

**重要な原則:**
- gemini-research は**調査・分析のみ**を担当する
- 実装コードは必ず Claude Code 自身が書くこと
- Gemini CLI は Web 検索を含むため、最新情報の取得に有効
- Plan mode 時のリポジトリ分析やライブラリ調査でも積極的に活用

### codex-review スキル使用時の特別ルール

codex-review スキルを使用して Plan→実装を行う場合、以下のワークフローを必ず完遂すること:

#### Complete Workflow（必須フロー）

1. **Phase 1: Plan Review**
   - Plan モードで計画作成
   - `mcp__codex__codex` でプランレビュー実施
   - sandbox: "read-only"
   - 計画の妥当性を確認

2. **Phase 2: Implementation**
   - 計画承認後、実装を完了
   - テストも含めて完全に実装

3. **Phase 3: Code Review Loop（最重要）**
   - **Phase 2 完了後、必ずこのフェーズを実行**
   - ユーザーの追加指示を待たず、自動的に開始

   実行手順:

   ```bash
   # 変更を収集
   git diff HEAD

   # CLAUDE.mdを読み込む
   Read CLAUDE.md

   # コードレビュー開始
   mcp__codex__codex:
     - sandbox: "workspace-write"
     - approval-policy: "on-failure"
     - プロンプト: コード品質、セキュリティ、パフォーマンス、ガイドライン準拠をチェック

   # 指摘があれば修正
   Edit/Write で修正を適用

   # 再レビュー
   mcp__codex__codex-reply で継続レビュー

   # 指摘がゼロになるまで反復（最大5回）
   ```

4. **Phase 4: Completion**
   - レビュー完了報告
   - 実装内容のサマリー
   - 解消した指摘数
   - 次のステップ提案

#### 絶対ルール

- **Phase 2（実装）完了時に「実装が完了しました」だけで終わらせない**
- **必ず Phase 3 のコードレビューループを実施してから完了報告**
- Phase 3 をスキップする場合は、ユーザーが明示的に「レビュー不要」と指定した場合のみ

### 全般

- **すべての作業に Subagents を積極的に利用する**
- **Plan mode で具体的な実装コードを確認したい場合**
  - プランに実装コード全体を含めてユーザーに提示
  - ユーザーが「いいね」「OK」と確認してから実装フェーズへ移行
  - 実装後の修正コストを削減
- **検証用の一時ファイル（test-*.mjs, verify-*.sh 等）**
  - ローカル動作確認のために作成した一時スクリプトはコミット対象外
  - git add 時に明示的に除外
  - 必要に応じて .gitignore への追加を提案
- ユーザーから修正指示を受けた場合の動作:
    - どのような作業にも適用できる汎用的な指示の場合は `~/.claude/CLAUDE.md` へ追記することを検討する
    - 追記を行うべきと判断した場合は、必ずユーザーへの確認を行う。承認が得られたバアにのみ追加作業を行うこと

### GitHub URL の扱い

GitHub の Issue や Pull Request など、ユーザーから提供された URL は Private Repository が多いため直接参照できないことが多い。そのため、原則ユーザーから提供された GitHub の URL に関しては `gh` コマンドを使って情報を参照すること。

## 設計原則

### 関数設計

- 単一責任原則は文脈に応じて柔軟に適用
    - 基本的には使用場所に応じた責任範囲で設計
    - 汎用的または複雑な処理は適切に分離
- 副作用の扱い
    - 内部実装では実用性を重視し、副作用を含むことを許容
    - 公開 API（export 関数など）は可能な限り純粋関数に寄せる
    - 非同期の副作用は適切にエラーハンドリング
- 引数の設計
    - 3 つ以上の引数はオブジェクトにまとめることを検討
    - セマンティクス的に自然な場合は、必須引数とオプションオブジェクトのハイブリッドも採用

### 抽象化

- いつ抽象化すべきか
    - よくある実装パターン（fetch、DOM 操作、DB アクセス等）は早期に抽象化
    - ドメイン固有の処理は Rule of Three（3 回目の実装で共通化を検討）
- 抽象化のレベル
    - 過度な抽象化は避け、適度な型定義やインターフェースに留める
    - 継承階層よりも、関数やシンプルな型を組み合わせる設計を好む
- インターフェースの粒度
    - 関連する操作を適切にグループ化した中程度の粒度
    - 単一メソッドインターフェースは細かすぎ、全機能インターフェースは大きすぎる

### 名前付けの哲学

- 略語の使用基準
    - 広く知られた略語（URL、API、ID 等）は使用可
    - ローカルスコープでは短縮形も許容（ループ変数の `i`、短い関数内の `res` 等）
    - プロジェクト固有の略語は避ける
- ドメイン用語の扱い
    - 業界標準の用語（MRR、SKU 等）は使用し、コメントで補足
    - 独自のビジネス用語は一般的な表現を優先
    - 必要に応じて JSDoc やインラインコメントで専門用語を説明
- 名前の長さと詳細度
    - エクスポートされる関数・変数は説明的な名前
    - ローカルスコープでは簡潔な名前
    - スコープの長さに比例して名前の説明性を調整

### 認知負荷の管理

- 一度に扱う概念の数
    - 各関数は 2-3 個の概念に限定
    - 複雑な処理は段階的に分解し、各段階で扱う概念を制限
    - 必要に応じてコンテキストオブジェクトでグループ化
- 暗黙知と明示的な設計
    - デフォルトの振る舞いは暗黙的でも可（キャッシュ、ログ等）
    - 重要な振る舞いの違いはメソッド名や引数で明示
    - セキュリティや副作用に関わる部分は必ず明示的に
- 読みやすさと書きやすさのバランス
    - 適切な中間変数で処理の意図を明確化
    - 意味のある単位でのグループ化とメソッドチェーン
    - 過度なワンライナーは避け、段階的な処理を心がける

## コーディング規則

### CSS/レイアウトのベストプラクティス

**flexbox と transform の相互作用:**
- flex コンテナ内で `transform: scale()` を使う場合、`flex-shrink: 0`（Tailwind: `shrink-0`）を指定して flex による縮小を防ぐ
- ブラウザデフォルトの `max-width: 100%` も transform との組み合わせで二重制約を引き起こすため、`max-w-none` も併用
- 例: 画像を transform でスケーリングする場合 → `class="shrink-0 max-w-none max-h-none"`

### ファイル構成

- 依存関係順にコードを配置（下から上へ読める構造）
    - 最初に基本的な定数、型定義、ヘルパー関数
    - 最後にそれらを使用するメインのロジックやエクスポート
- ファイルを下から読み上げることで依存関係が理解できる構成を意識
- 循環参照を避ける設計
